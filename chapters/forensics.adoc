//Forensics outline from Textbook0 Google Doc on shared picoCTF drive
//  The Worlds of Forensics
//    As a Profession
//    As a Capture-The-Flag Competition Category
//  Leading an Investigation
//    The Intuitive Leap
//    Courage with Small Leads
//    Relating Disparate Evidence
//    Getting Unstuck by Phoning a Friend
//  The Knowledge of Digital Structures
//    Bits, Nibbles, Bytes, Words, Double Words, Quad Words
//    Hardware of Storage Mediums (Hard Drives, Disks, etc.)
//    Software of Storage Systems (Filesystems, Memory Management, etc.)
//    Protocols of Communication Systems (TCP & other packet analysis)
//  Tools, Techniques & Procedures of Adversaries
//    Destruction of Hardware
//    Timestamp Manipulation
//    File Deletion
//    Hiding Files
//    Steganography

== Forensics

=== What is Forensics?

In general, computer science professionals refer to "Digital Forensics" as
"Forensics", for simplicity's sake. Digital Forensics is the field in
cybersecurity that tries to gather and understand evidence after an incident,
which can be crime, to determine how it happened. This not only helps law
enforcement when pledging someone innocent or guilty, but also to understand
how to improve security in a system that was successfully attacked. Digital
Forensics focuses on gathering evidence present in computer devices that hold
information electronically. It is a branch of Forensic Science, which can also
investigate any type of crime even if there is not computer media involved. 

=== How to search for strings and filenames

We will begin by learning how to search for information in a file system. Go
to the picoCTF webshell at:

https://webshell.picoctf.org/

Once you are connected, open up this problem in a separate tab:

https://play.picoctf.org/practice/challenge/85

Download the problem file in your webshell by right-clicking the link in the
problem description and selecting Copy Address or Copy Link. Then download it
by typing in `wget ` and pasting the address after 'wget', space. Your command
should look something like this, but is likely to not be exactly the same:

[source, text]
$ wget https://jupiter.challenges.picoctf.org/static/495d43ee4a2b9f345a4307d053b4d88d/file

You need to copy and paste your own link for the file.

Great! So now you should have the challenge file saved on your webshell as
`file`. Now what?

As a reflex, you should always use the program `file` on new files that CTF
challenges give you. The next command is kind of confusing, because the first
word references the program `file` and the second word references the file
named `file`, but run this command and see what it tells you:

[source, text]
$ file file

If done properly, it should tell you:

[source, text]
file: ASCII text, with very long lines

This tells us the file is plain text, but has unusually long lines. Since it
is plain text, we can use `cat` to see what it contains.

[source, text]
$ cat file

Running this command will show that the file is mostly made up of gibberish.
If this were a cryptography challenge, decoding the gibberish might be what
needs to happen, but this is a 100 point general skills question, so I doubt
that's what needs to happen here. What is the challenge author pushing us
towards? There's only one hint and it is a `grep` tutorial. What is grep?

Grep is a Linux utility, so we can learn about it by bringing up its man page:

[source, text]
$ man grep

The first line of the man page says:

[source, text]
grep, egrep, fgrep, rgrep - print lines that match patterns

This is perfect! We want to search through gibberish to find the flag. But how
do we specify the pattern to search for and the file to search in? For this,
I recommend the grep tutorial in the hint, not the man page. (Man pages tend
to be highly technical and can be confusing to novices)

One of the first examples in the grep tutorial uses the following command:

[source, text]
$ egrep 'mellon' mysampledata.txt

'mellon' is what is being searched for and it is being searched for in
'mysampledata.txt' What if we searched for 'picoCTF' in 'file'? That command
would look like:

[source, text]
$ egrep 'picoCTF' file

This should get the flag for you and print it on your screen.

Let's consider another challenge:

https://play.picoctf.org/practice/challenge/320

Download the zip file into your webshell like you did for the previous
challenge. As before, use `file` on it right away to have an idea of what
you're dealing with:

[source, text]
$ file files.zip

You should see the following output:

[source, text]
files.zip: Zip archive data, at least v1.0 to extract, compression method=store

To see more of this challenge, all we have to do is unzip the archive:

[source, text]
$ unzip files.zip

You'll see a lot of output, but you can ignore that for now. List the contents
of your current directory to see the new directory called 'files'. Try
exploring that a bit with `cd` and `ls`, remember that you're looking for a
file called 'uber-secret.txt'.

It may be hard to find 'uber-secret.txt' without the help of a tool. This
problem is called 'First Find' and our last problem was called 'First Grep'.
Is there a tool called 'find' in Linux? See if there is a manpage:

[source, text]
man find

There is! The first line reads:

[source, text]
find - search for files in a directory hierarchy

This sounds perfect. Exit the manual by pressing 'q'. As mentioned before,
manpages are quite technical and can be overwhelming to try and read when you
are first starting out. Let's find some simpler examples by Googling. My
Google query was `find file linux command`. I felt the need to specify `linux
command` because `find` is such a generic word. My top Google result was this:

https://www.plesk.com/blog/various/find-files-in-linux-via-command-line/

I especially liked this result because I know plesk is not a commercialized
site. Scroll down to the first example under `Basic Examples`.

[source, text]
find . -name thisfile.txt

This command means: starting in the current directory (which is what `.`, dot 
means), look in this directory and all subdirectories for the file named 
'thisfile.txt'. We can slightly modify this example to fit our needs for the
challenge.

Make sure you are in the 'files' directory for this command. If you unzipped
the archive in your home directory, you can use the following command to get
back to the 'files' directory:

[source, text]
$ cd ~/files

Once you're in the files directory, use this command:

[source, text]
$ find . -name uber-secret.txt

If you were in the 'files' directory when you ran this command, you should get
the following output:

[source, text]
----
./adequate_books/more_books/.secret/deeper_secrets/deepest_secrets/uber-secret.txt
----

This is the path to the file that was found. We're going to get into the same
directory as this file by following the directories listed in this file path.
We know that '.' is our current directory, so our first cd is to
'adequate_books'. Remember to use the Tab key to autocomplete unambiguous file
and directory names. To explain what I mean by 'unambiguous' here's a relevant
example of an ambiguous file name in our current context:

[source, text]
$ cd a

If you press the Tab key after only typing 'a' it won't autocomplete because
there are two directories that start with 'a', 'acceptable_books' and
'adequate_books'. The shell doesn't know which one you want. To get Tab to
autocomplete type the following unambiguous directory name and then strike
tab:

[source, text]
$ cd ad

When you press tab, it becomes:

[source, text]
$ cd adequate_books/

One last note on tab completion. When there is an ambiguous file name that
doesn't tab complete to something, you can hit the tab key again to see the
list of files that could be completed with your given prefix. The other
possibility is that there are zero matches on your given prefix, in which
case nothing is printed when you hit tab a second time.

So now we are in 'adequate_books', what's next? From our found file above,
'more_books' is after 'adequate_books', so we cd accordingly:

[source, text]
$ cd more_books/

For this directory, observe the difference between `ls -l` and `ls -al`. You'll
see that an additional directory is shown when the '-a' flag is given. This
flag means 'show all (including hidden files and directories)'. In Linux, any
file or directory starting with '.' is considered hidden and will only be
shown in specific circumstances.

[source, text]
$ cd .secret/
$ cd deeper_secrets/
$ cd deepest_secrets/

All of these cd commands could be combined into a single command, but I've
broken them up here for clarity and exposition. List the contents of
'deepest_secrets':

[source, text]
$ ls -al

To see the contents of the file, use `cat`:

[source, text]
$ cat uber-secret.txt

There's the flag for this challenge!

Try this slightly more difficult challenge with your new found skills:

https://play.picoctf.org/practice/challenge/322


=== Disk analysis

One of the most fundamental skills of a forensics analyst is inspecting and
deeply understanding disks. These can be actual hardware or dumps of disks
captured in files. There are a few really good GUI tools out there for not
just disk analysis, but whole management of digital evidence for cases. Our
disk analysis problems will not require any licenses to proprietary software.
Some people like to use Autopsy which is a GUI frontend to the tools we will
demonstrate how to use in this section. We will use the individual Sleuthkit
tools so that you learn a little more than from a GUI that abstracts away some
of the details. Disks are all about the details.

We will be considering disk images exclusively, due to the difficulty of
sending real hard drives through the Internet at the time of this writing! Try
this picoGym problem, which presents the first step in analyzing disk images:

https://play.picoctf.org/practice/challenge/301

This problem should be pretty approachable given what you've done leading up
to this point, namely downloading individual challenge files and using command
line utilities. Something new in this challenge is using netcat or `nc`. For
this challenge, nc is used to access a checker program. This program will check
your answer to the challenge and give you the flag if it is correct. For this
challenge, the invocation of nc (what you type to run it) is given and is
straightforward, but I will explain it for the sake of clarity. Here's my given
nc invocation: `nc saturn.picoctf.net 52279` The last number might be different
for you, that's expected. We'll go through what each part of this program call
means:

* `nc` This, of course, is the name of the program we are running. Netcat, or
  'nc' as this system calls it. Sometimes the program name will be the full
  'netcat' variety, but on the webshell, it is 'nc'.
* `saturn.picoctf.net` This is the name of the computer we're connecting to.
  This is a challenge server that picoCTF runs.
* `52279` This is the number of the port we're connecting to for the challenge.
  This will probably be different for your challenge.

So go ahead and solve your first Sleuthkit problem on the picoGym and learn the
tool, `mmls`, which we will use for subsequent problems.

Here's the next challenge in that short series:

https://play.picoctf.org/practice/challenge/300

This challenge requires `mmls` as a first step to use other Sleuthkit tools,
but now is the time for some true forensic background.

A disk image is a huge dump of many numbers. But these numbers have an
invisible structure to them that gives them much more meaning. Navigating
this invisible structure manually is tedious and deeply difficult, but the
Sleuthkit tools handle this invisible structure for us. To begin using the
Sleuthkit tools we must understand some of the layers that apply to disk
images. The four main layers are: media, block, inode, and filename.

* Media: the media layer tools all are prepended with 'm' and operate on the
  disk image with little guidance from the analyst. `mmls` is a media-layer
  tool that gives us the partition table of the image and key information for
  delving into the other layers. Media is the lowest level, providing key
  information to access the deeper layers, but not shedding much light on the
  data contained in the image.
* Block: the block layer is the second lowest level of the four layers
  considered here. It's the numbers of the disk image broken into equal-sized
  chunks. A single file is likely to contain multiple blocks.
* Inode: the inode layer is like the bookkeeping layer of a disk image. It's
  like the table of contents, with the chapter numbers being like the inodes,
  and the page numbers like the blocks of a file.
* Filename: the filename layer is one layer that most any user of a computer
  actually sees and interacts with. This is the layer with which we will start 
  our exploration of the Sleuthkit in the current challenge. Interacting with
  the filename layer will look a lot like using the shell normally.
